参考：
- [深入理解Java类加载器(ClassLoader)【CSDN】](https://blog.csdn.net/javazejian/article/details/73413292)
- [类加载器沉入理解](https://www.2cto.com/kf/201608/536691.html)
- [JVM高级特性与实践（九）：类加载器 与 双亲委派模式（自定义类加载器源码探究ClassLoader）【CSDN】](https://blog.csdn.net/itermeng/article/details/75669628)

## 类加载机制的层次结构
每个编写的”.java”拓展名类文件都存储着需要执行的程序逻辑，这些”.java”文件经过Java编译器编译成拓展名为”.class”的文件，”.class”文件中保存着Java代码经转换后的虚拟机指令，当需要使用某个类时，虚拟机将会加载它的”.class”文件，并创建对应的class对象，将class文件加载到虚拟机的内存，这个过程称为类加载，这里我们需要了解一下类加载的过程，如下：

![类加载过程图](https://raw.github.com/EnochStudio/MarkdownPhoto/master/classLoadingProcess.png)

![类加载过程图2](https://raw.github.com/EnochStudio/MarkdownPhoto/master/classLoadingProcess2.png)


- 加载：通过一个类的完全限定查找此类字节码文件，并利用字节码文件创建一个Class对象
- 验证：目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。
- 准备：为类变量(即static修饰的字段变量)分配内存并且设置该类变量的初始值即0(如static int i=5;这里只将i初始化为0，至于5的值将在初始化时赋值)，这里不包含用final修饰的static，因为final在编译的时候就会分配了，注意这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。
- 解析：主要将常量池中的符号引用替换为直接引用的过程。符号引用就是一组符号来描述目标，可以是任何字面量，而直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。有类或接口的解析，字段解析，类方法解析，接口方法解析(这里涉及到字节码变量的引用，如需更详细了解，可参考《深入Java虚拟机》)。
- 初始化：类加载最后阶段，若该类具有超类，则对其进行初始化，执行静态初始化器和静态初始化成员变量(如前面只初始化了默认值的static变量将会在这个阶段赋值，成员变量也将被初始化)。

## 类加载和初始化时机

1. 类加载时机

    当应用程序启动的时候，所有的类会被一次性加载吗？估计你早已知道答案，当然不能，因为如果一次性加载，内存资源有限，可能会影响应用程序的正常运行。那类什么时候被加载呢？例如，A a=new A()，一个类真正被加载的时机是在创建对象的时候，才会去执行以上过程，加载类。当我们测试的时候，最先加载拥有main方法的主线程所在类。

2. 类初始化时机

    **主动引用(发生类初始化过程)**
    - new一个对象。
    - 调用类的静态成员(除了final常量)和静态方法。
    - 通过反射对类进行调用。
    - 虚拟机启动，main方法所在类被提前初始化。
    - 初始化一个类，如果其父类没有初始化，则先初始化父类。    
    **被动引用(不会发生类的初始化)**
    - 当访问一个静态变量时，只有真正声明这个变量的类才会初始化。(子类调用父类的静态变量，只有父类初始化，子类不初始化)。
    - 通过数组定义类引用，不会触发此类的初始化。
    - final变量不会触发此类的初始化，因为在编译阶段就存储在常量池中。
    
## 类加载器
虚拟机设计团队把类加载阶段中“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的模块称为“类加载器”。

类加载器在类层次划分、OSGI、热部署、代码加密等领域大放异彩，成为了Java技术体系中一块重要的基石。

### 类的唯一性
> **对于任意一个类，都需要由（实际）加载它的类加载器和类的全限定名一同确定其在Java虚拟机中的唯一性。**

换句话说就是，比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那这两个类就必定不相等。

这里所指的“相等”，包括Class对象的equals()方法，isAssignableFrom()方法、isInstance()方法的返回结果，也包括使用instanceof关键字做对象所属关系判定等情况。

### 类加载器的命名空间
每个类加载器有自己的命名空间，命名空间由所有以此加载器为初始加装载器的类组成。

不同类加载器的命名空间关系：

1、同一个命名空间内的类是相互可见的，即可以互相访问。

2、父加载器的命名空间对子加载器可见。

3、子加载器的命名空间对父加载器不可见。

4、如果两个加载器之间没有直接或间接的父子关系，那么它们各自加载的类相互不可见。


### 类加载器分类
从Java虚拟机的角度讲，只存在两种不同的类加载器：
- 启动类加载器（Bootstrap ClassLoader）：这个类加载器使用C++语言实现，是虚拟机自身的一部分。
- 其他的类加载器：这些类加载器由Java语言实现，独立于虚拟机，并且全部都继承自抽象类java.lang.ClassLoader。

从Java开发人员的角度讲，类加载器还可以划分得更加细致一些，绝大多数Java程序都会使用到以下三种系统提供的类加载器
- 启动类加载器（Bootstrap ClassLoader）：由C++语言实现（针对HotSpot）,负责将存放在<JAVA_HOME>\lib目录中，或者被-Xbootclasspath虚拟机参数指定的路径中，并且是虚拟机识别的类库加载到虚拟机内存中。（仅按照文件名识别，如rt.jar，名称不符合的类库即使放在lib目录中也不会被加载。）
- 扩展类加载器（Extension ClassLoader）：这个类加载器由sun.misc.Launcher&ExtClassLoader实现，它负责加载\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。
- 应用程序类加载器（Application ClassLoader）：这个类加载器由sun.misc.Launcher$ApplicationClassLoader实现。由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，所以一般也称为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。

我们的应用程序都是由这三种类加载器相互配合进行加载的，如果有必要，还可以加入自己定义的类加载器。

![类加载器层次图](https://raw.github.com/EnochStudio/MarkdownPhoto/master/classLoaderArchitecture.png)

类加载器之间的层次关系，称为类加载器的双亲委派模型。双亲委派模型要求除了顶层的启动类加载器外，其余类加载器都应该有自己的父类加载器。**注意，这里类加载器之间的父子关系一般不会以继承的关系实现，而是使用组合关系来复用父加载器的代码**。


### 双亲委派模型（Java 1.2引入）
#### 双亲委派模型的定义和原理
双亲委派模型工作过程是：如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成。每个类加载器都是如此，只有当父加载器在自己的搜索范围内找不到指定的类时（即ClassNotFoundException），子加载器才会尝试自己去加载。

#### 为什么需要双亲委派模型？
为什么需要双亲委派模型呢？假设没有双亲委派模型，试想一个场景：

黑客自定义一个java.lang.String类，该String类具有系统的String类一样的功能，只是在某个函数稍作修改。比如equals函数，这个函数经常使用，如果在这这个函数中，黑客加入一些“病毒代码”。并且通过自定义类加载器加入到JVM中。此时，如果没有双亲委派模型，那么JVM就可能误以为黑客自定义的java.lang.String类是系统的String类，导致“病毒代码”被执行。

而有了双亲委派模型，黑客自定义的java.lang.String类永远都不会被加载进内存。因为首先是最顶端的类加载器加载系统的java.lang.String类，最终自定义的类加载器无法加载java.lang.String类。

或许你会想，我在自定义的类加载器里面强制加载自定义的java.lang.String类，不去通过调用父加载器不就好了吗?确实，这样是可行。但是，在JVM中，判断一个对象是否是某个类型时，如果该对象的实际类型与待比较的类型的类加载器不同，那么会返回false。

![双亲委派模型流程图](https://github.com/EnochStudio/MarkdownPhoto/blob/master/parentsDelegationModelFlowChart.png)

## 自定义类加载器
- 继承自ClassLoader；
- override父类ClassLoader的findClass()方法；
查看ClassLoader的源码就能很好的理解为什么类加载器的步骤是这样.
