# 算法笔记

1. 判断一个数是否是素数
- 素数的最小质因子小于等于其平方根
- 从2开始遍历到n-1，若能整除则不为素数
- 
2. 动态规划


## 消除嵌套括号
1. 判断括号是否匹配
2. 消除括号（保留第一个号最后一个左右括号）

作法：
- 遍历字符串数组，定义左括号起始，如果为左括号变量+1，右括号变量-1，若最后不为0则括号不匹配。
- 遇到其他字符则加入到字符串中，最后字符串以右括号结束


## 不适用比较运算符求出两个数的最大最小值

思想：借助公式实现
- （x+y）-|x-y|)/2求最小值
- （（x+y）+|x-y|)/2）求最大值

## 二叉树

树的高度与结点的高度：
**高度从叶节点到根节点**

- 树的高度等于树的深度
- 结点的高度与深度不一定相等

树的深度与结点的深度：**层数根节点开始**
- 树的深度：所有节点的最大层数
- 结点的深度：层数

树的度：结点度的最大值

满二叉树与完全二叉树：
满二叉树是完全二叉树，完全二叉树不一定是满二叉树

完全二叉树的性质：（i为结点的编号，从1开始编号,n为结点的个数）
1. i>1,i/2为双亲结点
2. 2i<=n，i的左孩子结点为2i，否则无左孩子
3. 2i+1<=n,i的右孩子结点为21+1，否则无右孩子

二叉树：
1. 度为0的结点比度为2的结点多一个
2. i层结点最多为 2的i-1次方
3. 二叉树的深度为k，结点最多为2的k次方-1


### 实现二叉排序树
二叉树结点的数据结构
```java
class Node{
    public int data;
    public Node left;
    public Node right;
    public Node(int data){
        this.data = data;
        this.left = null;
        this.right = null;
    }
}
```

构建二叉排序树（成员变量根节点 Node root）

步骤：
1. 遍历数组，一个一个数据插入
2. insert，插入是先new Node（data）；若根节点为null则为根节点，否则寻找插入的位置
3. 定义遍历结点从根节点开始，定义parent节点记录当前的遍历结点的父节点，找到currnt为null的结点插入。
```java
 Node current = root;
 Node parent = null;
 while(true){
 parent = current;
 if(data<current.data)  //如果结点的值比根节点小则插入到左子树
    current = current.left;  //记录遍历结点的父节点
    if(current == null)
      parent.left = newNode;
      return;
 else{
    current = current.right;
    if(current == null)
      parent.right = newNode;
      return;
 }
 }
```
递归实现中序遍历：左子树-根(system.out.println(root.data))-右子树
递归实现先序遍历：根-左子树-右子树
递归实现后序遍历：左子树-右子树-跟


队列实现二叉树的层序遍历

步骤：

1. 根节点入队列
2. 每次从队列中取出一个结点，打印输出，然后这个结点有左右孩子都入队，循环直至队列为null

已知先序、中序，求后序遍历（数组操作）
1. 确定根节点的位置 先序遍历的第一个结点
2. 求解根节点的左右子树 根节点的左右方为左右子树
3. 对二叉树的左右孩子分别求12步骤

大致为构建二叉树、后序遍历输出（递归实现二叉树的构建）
先序找到根节点在中序中的下标，截取根据下标截取左右子树再求根节点，再进行根节点的寻找，直到最后head.left = left ,head.right = right


求二叉树中节点的最大距离

思路：
最大距离（左子树中距离根节点的最大距离+右子树距离根几点的最大距离）

1. 节点的定义多两个左右子树的最大距离
2. 采用递归的方式从叶节点开始算左右子树的最大距离，最后求出根节点的左右子树最大距离相加即为二叉树中节点的最大距离。

### 字符串
判断一个字符串中单词的个数
思路：
- 使用字符串的split函数，再除去空格
- 除去空格可以借助StringBuffer实现（不使用数组实现因为数组的新增和删除比较麻烦），非“”字符append到字符串中并添加；然后再用split分割就又得到字符串。

按要求打印数组的排列情况（打印数组的全排列）

题目：1,2,2,3,4,5,六个数字，打印所有不同的排列，要求4
不能放在第三位，3/5不能相连

思路：
- 打印数组的排列可以通过图的遍历实现，对图进行深度优先遍历
- 构建无向连通图，使用邻接矩阵存储（在构建时实现题目中的要求，邻接矩阵0表示可达，1表示不可达，相同元素不可达置0）
- 从不同节点出发深度优先遍历图
- 使用set存储，set可以保证元素的唯一
- 遍历set集合打印输出结果

深度优先遍历使用递归实现：
- 对每一个结点深度优先遍历得到下一个结点，在对下一个结点同样使用深度优先遍历
- 每次先判断长度是否为n，再看第三位是不是4
- 每一次递归结束之后恢复每个结点的标志位使得其他的遍历顺序可以访问到该节点
- 与深度优先遍历不同的一点 不可达的情况抛弃，必须每一个遍历都遍历完所有的结点


解释：

广度优先遍历-----概念就是左看看右看看，雨露均沾

深度优先遍历-----一条道走到黑，走不完再回头走


输出字符串的所有组合

给“abc”，输出其所有的组合
思路：

1. 迭代 按照取字符串的长度循环（1-len），然后每个字符取就添加到StringBuffer中，用迭代指针判断一个循环是否执行完成，用长度判定输出，比如取长度为1的字符串，在长度减一之后是否为0，
2. 
```java
    public static void Combine(char[] c){
        if(c == null)
            return;
        int len = c.length;
        boolean[] used = new boolean[len];//表示取还是不取的标志  正向循环
        char[] cache = new char[len]; //取的字符 反着存
        int result = len; //记录取1的数的位置，从后往前保存 例如一个字符就保存在cache的最后一个位置result为2，ab的话result就为1
        while (true){
            int index = 0;
            while (used[index]){
                used[index] = false;
                ++index;
                ++result;
                if(index == len)
                    return;
            }
            used[index] = true;
            cache[--result] = c[index];
            System.out.println(new String(cache).substring(result));
        }

    }
```
### 求a的n次方的优化（二进制法）
[参考文章](https://blog.csdn.net/lubiaopan/article/details/4868206)

1. 幂次用二进制表示
2. result = 1；
3. 使用与1相与然后右移获取二进制的每一位
4. 若为1则与result与a相乘，若为0则a与a相乘
5. 先执行a与a相乘的一步（a几何递增），再去右移操作

```java
public class TestPower{
 public static void main(String args[]){
  System.out.println(f(2,100));
 }
 private static long f(int a,int n){
  long result=1;
  while(n!=0){
   if((n&1)==1){
    result=result*a;  
   }
   a=a*a;
   n=n>>1;
  } 
  return result;
 }
}

```

### 位运算

移位操作实现乘法

思路：左移扩大2倍，且左移无论正负数都是右补0不用考虑符号问题

判断一个数是够为2的n次方

思路：让1一直左移，途中判断一下有没有与原数相等的，相同则为true，判断条件是左移后的数小于等于原数

求二进制数中1的个数

思路：
1. 第一种求出二进制数中每一位数判断是否是1即可，先与1相与，然后右移1位
2. 第二种 **n与（n-1）相与其结果都会少一位1而且是最后一位**，一直进行此运算只要n！=0，count++；

### 栈与队列

栈和队列都可以用数组和链表实现

**栈**

数组实现

需要记录数组的大小 size

数组  Object[] stack

删除栈顶元素pop：先取出栈顶元素 E e = (E)stack[size-1];

入栈 push ：
1. 先检查容量 Arrays.copyof（stack，newLen）;
2. 然后在数组尾部添加元素并且size+1（stack[size++]= e）

链表实现：

需要记录链表的头结点 用top指针 Node<> top = null;

入栈push操作：使用头插法，每次入栈的元素都是栈顶元素

newNode.next = top;

top = newNode;

出栈操作：pop

先返回top.data的值

top = top.next; 

O(1)复杂度求栈中最小的元素（空间换时间 借助另外一个栈，在入栈的时候确定最小的元素）

思路：一个栈用来存储数据，另一个栈用来保存最小的元素值

**队列**

数组实现：

如果依旧是数组实现队列，则会存在出队列是数组中元素移位的操作，因此使用LinkedList方式，使用addLast()添加元素，使用removeFirst()移除第一个元素。

链表实现：

记录头指针和尾指针

使用尾插法入队，tail.next() = newNode；
tail = newNode；

出队pop() 

E data = head.data;

head = head.next;

两个栈模拟队列：

A栈提供入队操作，B栈提供出队列操作。

入队：s1.push(e);

出队：
```java
if(s2.isEmpty()){
    while(!s1.isEmpty())
    s2.push(s1.pop());
}
return s2.pop();

```

### 排序

- 内部排序（插入排序、选择排序、交换排序）

排序期间元素全部放在内存中
- 外部排序(多路归并排序)

排序期间元素无法全部同时放在内存中，必须在排序的过程中根据要求在内外存之间移动的排序，**经常用于对大文件进行排序**

外存设备一般为磁盘、磁带

操作系统按块对磁盘上的信息进行读写的，读写时间远远超过内存运算的时间，因此外部排序的时间代价主要考虑访问磁盘的次数。I/O次数

外部排序的大致方法：
1. 根据内存大小将外存中n个记录分为长度为h的若干个子文件，依次读入内存
2. 利用有效的内部排序方法进行排序，将排序后的有序子文件称为**归并段**，然后写回外存
3. 对这些归并段进行逐趟归并，使归并段逐渐有小到大，直至整个文件有序为止。

10G数据 4KB的内存

分成2500000个数据段读入内存进行内部排序，形成2500000个有序段
然后进行25000000路归并排序

提升外部排序的效率:
1. 增加归并的路数m
2. 减少初始归并段的个数r


归并排序的时间复杂度：
O(nlogn) 每一趟O（n），总共是二叉树树的高度logn趟

快速排序

快排的时间复杂度是根据递归计算的，平均情况下为O(nlogn);
```java
   //快排（一趟排序）
    public static int partition(int[] array,int low,int high){
        int pivot = array[low];
        while (low<high){
            while (low<high&&array[high]>=pivot) high--;
            array[low] = array[high];    //将枢纽元素替换为比其大的值
            while (low<high&&array[low]<=pivot) low++;
            array[high] = array[low];                     //一趟排序相当于每次都与枢纽元素交换，代码中写的是low、high之间的交换
        }
        array[low] = pivot;
        return low;  //返回枢纽元素的index
    }
```

快排按照降序排序
```java
 //快排（一趟排序）   降序排序
    public static int partition(int[] array,int low,int high){
        int pivot = array[low];
        while (low<high){
            while (low<high&&array[high]<=pivot) high--;
            array[low] = array[high];    //将枢纽元素替换为比其大的值
            while (low<high&&array[low]>=pivot) low++;
            array[high] = array[low];                     //一趟排序相当于每次都与枢纽元素交换，代码中写的是low、high之间的交换
        }
        array[high] = pivot;
        return high;  //返回枢纽元素的index
    }
```

找出数组中第K大的数

1. 一趟快排（降序）
2. 如果pivot+1（即排序后数组枢纽元素的排行）==K 则pivot就为第K大元素
3. 如果pivot+1<k 则第K大元素在枢纽元素右边的数组中，位置是K-temp（枢纽元素的下标）


### 链表

添加结点

- 头插法 newNode.next = head;head = newNode;
- 尾插法 循环找到最后一个结点插入

删除结点：
- 删除第一个结点 head = head.next;
- 删除结点需要记录其前驱结点

删除链表中的重复元素（同删除字符串中的重复字符一样--双重遍历）

- 双重遍历
- 借助HashTable记录元素是否已经出现过

找出单链表中倒数第K个元素

- 找出单链表的长度 一次遍历
- 找到正数第n-k个元素，下一个就是倒数第K个元素

第二种思路：

1. 设置两个指针指向头结点
2. 快指针先行k-1步，然后两个一起走，直到快指针走到最后。慢指针的位置就是倒数第K个元素。

链表的反转：

思路：
需要找到最后一个结点为头结点

需要三个指针-遍历指针，遍历指针后继结点的指针（在翻转之后，遍历指针就会丢失，因此需要保存遍历时的状态），前驱指针（用来链表反转时使用）

```java

Node pNode = head; //遍历指针
Node perNode = null; //前驱指针
Node pReverseNode = null;//记录新的头指针
while(pNode!=null){
 Node pNext = pNode.next;
 id(pNext==null){
     pReverseNode = pNode;
 }
 //进行反转
 pNode.next = preNode;
 preNode = pNode;
 pNode = pNext;
}
```

从尾到头输出单链表

思路：反转单链表然后输出

使用栈---想到递归

```java
if(head!=null){
    printListReversely(head.next);
    System.out.println(head.data);
}
```

找到链表的中间节点

- 设置快慢两个指针，快指针一次两步，慢指针一次一步。快指针走到链表尾部时慢指针的位置即为中间节点的位置
- 链表长度为奇数，慢指针的位置刚好是中间节点
- 链表长度为偶数时，慢指针的位置和下一个位置都是中间节点
if(fast!=null&&fast.next!=null&&fast.next.next!=null){
    /////////////////////////////
}

检测一个单链表是否有环

思路： 设置两个指针，一个快一个慢，快指针每次走两步，满指针每次走一步，在快指针和next不为null的前提下如果快指针与满指针相遇则有环

如何找到有环链表的入口点：

**在链表头和相遇点设置各设置一个指针，每次各走一步。两个指针必定相遇相遇的第一点就为环的入口点**

如何在不知道头指针的情况下删除指定结点

给定一个结点让删除

思路：如果是尾结点则不能删除，因为不知道其前驱结点

如果不是为节点，则可以交换后继结点的值，然后删除后继几点

```java
if(n==null||n.next==null)
return false;
n.data = n.next.data;
n.next = n.next.next;
```

如何判断两个链表相交：

相交的两个链表从交点到后边结点使重合的因为只有一个后继指针
如果两个单链表相交则两个单链表有相同的尾结点

因此找到两个单链表的尾结点比较就行了。

如何找到相交的单链表的第一个相交点？

找到两个链表长度的差值，长度长的链表先走len2-len1个结点，然后在一起走判断交点。


### 数组


找到数组中第二大的数

维持两个变量 max，sec-max一次遍历，只要能找到比最大数大的数就把最大的数给第二大的数，找不到，就和第二大的数比较。

求最大子数组的和

以往的双重循环，终点可定，即确定一个起点，从起点到终点是一次

而求一个数组所有的子数组时，起点i从0-n，但是终点未定，需要从
i到n,然后根据不同的重点进行循环求所有的子数组。


思路： 一维动态规划

原题为求0-n数组的最大子数组的和转化为

求包含0-i元素的数组的最大子数组，慢慢到n

因为是连续的子数组，所以还需要判断一种情况是是否包含i，因此是三种情景求最大值写出状态转移方程

A[i] 要么是arr[i] 要么是包含i-1数组的和+arr[i] 要么是不包含arr[i] 也就是A[i-1]

A[i] = Max(A[i-1],Max(End[i-1]+arr[i],arr[i]))

合唱团的问题多了一个变量K控制选取的人数，因此是二维的动态规划问题

求数组中两两相加等于20的组合数

双重遍历数组求两个数的和是否等于20

或者先排序，然后用两个指针控制。像快排一样，一个从前一个从后，看相加是否大于20.这样一次遍历就可以求出。因此时间复杂度为O（nlogn）。

如何把一个数组循环右移K位

思路：急用StringBuffer先保存后边K位，在循环数组保存前边的size-k位，然后转换为字符数组再转换为int数组

或者三次逆序，前size-k逆序，后k为逆序，所有都逆序

**右移K位于右移K%n位结果一样，当K比N大的时候，适用于位右移运算**


如何找出数组中只出现一次的数字

整形数组除了一个数字，其他都出现了两次。找出这个出现一次的数字

思路：适用异或运算符，任何数异或自己都是0；只有01异或才是1，因此相同的数异或为0，那0与出现一次的数字异或就为那个数字本身、

异或的情况只能是其他数字出现次数为偶数的情况，如果其他数字出现次数为奇数，就不能
使用异或的方法。

如果数组中一个数字出现的次数都为n，则每一位上1的个数都可以被n整除。因此如果数组中出现一次的数不存在，则每个二进制位上的1的个数和都能被n整除。因此对每位上1的个数取余，就可以得到这个数的二进制形式。

```java
package Arrays;

public class OnceTimeNum {

    public static void main(String[] args) {
        int[] arr = {1,2,1,2,4,2,4,4,1,3};
        System.out.println(findOnce(arr,3));
    }

    public static int findOnce(int[] arr,int appearTimes){
        //统计每一位上的1的个数   倒着存的
        int n = arr.length;
        int[] counts = new int[32];
        for (int i=0;i<32;i++){
            for (int j = 0;j<n;j++){
                if((arr[j]&1)==1)
                    counts[i]++;
                arr[j] = arr[j]>>1;
            }
        }

        int res = 0;
        //复原
        for (int i=0;i<32;i++){
            counts[i] = counts[i]%appearTimes;
            res |= (counts[i]<<i);
        }
        return res;


    }
}

```
复原的时候要注意左移i位然后与结果相余即可


找出数组中唯一重复的元素

采用异或的做法，1-N-1异或结果再与 数组中全部的数的异或结果相异或，结果就为那个重复的值 (a^b)^(a^a^b)= a a即为重复的值

使用递归求整形数组中的最大元素

第一个位置与其他位置比较，相当于倒叙遍历数组，递归终止条件length=1
```java
if(length==1)
return a[begin];
else
return max(a[begin],maxNum(a,begin+1))
```

求数对只差的最大值

数组中一个数组减去右边子数组的一个数字可以得到差值

以为动态规划问题

diff[i]   i是下标转换问题的时候一般是i+1个数或者人之类的。应表示为前i+1个数构成子数组的最大差值。 

状态转移方程：
diff[i+1]两种可能，要么是diff[i],max[i-1]-a[i] 

求绝对值最小的数（有序数组）

思路：求出数组中每个数的绝对值然后比较那个最小即可。

分三种情况
1. 全正数    数组中第一个元素
2. 全负数    数组中最后一个元素
3. 正负都有  找到正负分界点，比较分界点左右的正数负数的绝对值确定最小的数

查找正负分界点：

二分查找

求数组中两个元素的最小距离

每次记录n1,与n2的下标，遇到n1时与上次的n2的下标求差值，取最小值。遇到n2也一样

求指定数字在数组中第一次出现的位置

前提是数组中相邻元素之差为1

使用跳跃搜索法-看待查找元素与第一个元素的差值

```java
i=0;
while(i<len){
    if(a[i]==t)
    return i;
    else{
        i+= Math.abs(t-a[i]);
    }
}
```

如何对两个有序段进行合并

思路：找到0-mid-1中比mid大的数与mid交换，然后数组后半段使用冒泡排序的方法。因为数组整体有序，一趟冒泡排序就可以将交换过来的数字有序的插入到后边的有序段中。

如何计算两个有序整数数组的交集

顺序遍历两个数组，采用额外的空间，Map存储数字以及出现的次数，出现次数为2的数字即为交集元素

如何判断一个数组中数值是否连续相邻

数组中数值乱序，0可以是统配数值，0可以出现多次，全0是连续，只有一个非0也是连续，相同的数不会同时出现

思路：找出非0的最大最小值，如果最大最小之间的差值小于等于n-1，则n个数相邻，否则不相邻

因为如果不存在0的情况下，最大最小值在不存在重复元素的情况下的差值等于n-1.存在0则差值小于4

数组中反序对的个数

反序对就是 a[i]>a[j],i<j 则a[i]与a[j]为一个反序（前边的数大于后边）

求解最小三元组的距离（每个数组都是升序的）

蛮力遍历三个数组，找到所有的三元组，求最小的距离

简化思路：
从三个数组第一个元素开始，计算他们的距离mainDist。然后找最小的元素，从最小元素数组往后遍历。每次遍历都要找最小的元素。重复此步骤。

